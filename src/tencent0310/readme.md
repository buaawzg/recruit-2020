# tencent 0310

## Test1 - n 个检查点通过 n - 1 个

一个游戏, 直线上有 `n` 个检查点, 你需要通过其中的 `n - 1` 个检查点, 求出最短的路径长度
给定直线上 n 个点的位置, 以及你的起始点位置  

1. ***起始点比最小值小***
2. ***起始点比最大值大***
3. ***起始点在最大值和次大值之间***
4. ***起始点在最小值和次小值之间***
5. ***other***

## Test2 - 登塔

攀登一座塔, 你可以爬 `1` 层, 消耗体力等于该层塔的高度, 也可以跳 `1` 层或者 `2` 层, 但是不能连续跳 `2` 次, 即你跳过一次后下一次必须爬   

***动态规划: 每一步记录两个状态, 一个是如果该层是爬上来的最短时间, 一个是该层是跳上来的最短时间***

```
dp[i][0] = Math.min(dp[i-2][1], dp[i-1][1]) // 该层是跳上来的最小花费
dp[i][1] = Math.min(dp[i-1][0], dp[i-1][1]) + h[i] // 该层是爬上来的最小花费
```

## Test3 - 出队顺序

`1 - n` 出队和移到队尾交替进行 
 
***队列模拟即可***

## Test4 - 黑白块

矩形区域黑白块交替, `mat[0, 0]` 为黑, 先选一个小区域涂成白色, 再选另一个小区域涂成黑色, 最后黑白各多少个

***计算黑块有多少个***

1. ***涂成白色 黑块总数减去该区域所有黑块数***
2. ***涂成黑色 黑块总数加上该区域所有白块数***
3. ***重合的部分所有白色变成黑色, 初始状态是白色变成黑色的不用计算了(`2`中已经计算), 需要加上的就是最初状态是黑色, 在 `1` 中被涂成了白色的数量, 也就是黑块总数加上重叠区域最初的黑块数目***

## Test5 - 最小差值

对于数组中的每一个数 `arr[i]` , 求在该数前边的 `min(abs(arr[j] - arr[i]))`, 其中 `j < i`  
对前面的数据进行二分查找, `TreeMap`二分查找