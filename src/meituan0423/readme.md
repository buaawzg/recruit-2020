# meituan 04.23

## Test1 黑白矩阵

黑白矩阵: 矩阵内的任意一个元素, 其上下左右的数字完全一致(如果存在)且不和本身重复   
矩阵 `A`, 大小为 `n * m`, 元素为整数, 至少修改几个元素使矩阵 `A` 为黑白矩阵

1. ***修改后的矩阵要像一个国际象棋的棋盘一样, 黑格数字全部一样, 白格数字全部一样。***
2. ***分别统计所有白格和黑格中出现次数最多的数字和第二多的数字***
3. ***如果黑白格中出现最多次数的数字不相等, 直接输出 `n * m - 黑格出现次数最多的数字的次数 - 白格出现次数最多的数字的次数`***
4. ***如果黑白格中出现最多次数的数字相等, 那么输出 `n * m - 黑格出现次数最多的数字的次数 - 白格出现次数第二多的数字的次数` 和 `n * m - 白格出现次数最多的数字的次数 - 黑格出现次数第二多的数字的次数` 的最小值***

## Test2 格子染色

无限大的二维网格, 给出 `n` 对起始点和终点的坐标   
染色两个坐标区间内的格子(含起始点终点), 交叉部分算一次, 求共染色多少个格子   
给出的坐标如果横坐标相等, 是一条横线; 如果纵坐标相等, 是一条竖线   

1. ***构造线段存储结构 `Interval` 包含起点和终点 `start end`***
2. ***构造一个直线(横或者纵)上的存储结构 `Line` 包含横坐标或纵坐标 `index` 以及 不重合的线段区间 `list` , 表示 `x(或者y) = index` 这条直线上有几个不重合的线段***
3. ***对每一条横线段或者竖线段, 都放入到对应的直线的 `list` 中去, 此时每个线段可能有重合***
4. ***对每一条直线上的线段集合进行合并(参见[leetcode 56 区间合并](https://leetcode-cn.com/problems/merge-intervals/)), 构造内部线段不重合且排好序的直线存储, 此时所有水平与水平重合的点, 竖直与竖直重合的点全部去重完毕***
5. ***对所有的横直线按照 `index` 排序, 同时对所有的竖直线按照 `index` 排序***
6. ***计算横直线和竖直线中的每条线段包含的点的总数, 因为对线段进行了合并操作, 所以此时所有的交叉点只会重复计算了两次***
7. ***计算交叉点的个数, 计算方法如下:***   
   1. *对每一条横直线, 求出该横直线与所有的的竖直线有多少个交叉点*   
   2. *对一条横直线的所有线段(内部线段已经排好序)和所有的竖直线, 如果竖直线的 `index` 在某条线段的起点和终点之间, 则可能存在交叉(如果交叉, 只有一个交叉点), 否则不可能*   
   3. *所有线段从起点最小的开始, 所有竖直线从 `index` 最小的开始*
   4. *如果当前竖直线 `index` 小于当前线段起点, 竖直线后移*   
   5. *如果当前竖直线 `index` 大于当前线段终点, 线段后移*   
   6. *当前竖直线 `index` 在当前线段起点和终点之前, 判断当前线段与当前竖直线中的线段是否相交, 相交则交叉点个数加 `1`, 同时无论是否相交, 竖直线都要后移*   
8. ***点的总数减去交叉点总数***

## Test3 矩形相交面积

**从第二题扩展的题目, 去年网易有一道笔试题, 给出 `n` 个矩形, 求平面中相交矩形最多的区域, 输出个数**   
矩形给出左上角坐标和右下角坐标如 `(0, 0, 1, 1)`, 这个小矩形面积为 `1`, 和上题不同, 这里是为了计算方便   
现在求出所有矩形覆盖的面积[leetcoe 850. 矩形面积 II](https://leetcode-cn.com/problems/rectangle-area-ii/)   

### 解法1

1. ***构造线段数据结构(为横坐标) `Interval`, 包含起点和终点***
2. ***对所有的横坐标分线段区间并排序 `intervals`***
3. ***构造矩形边的数据结构(为纵坐标) `Line`, 包括高度 `index`, 上下边标记  `flag = 1 => 下边, flag = -1 => 上边`, 边的左右端点 `start end`***   
4. ***对所有上下边按照 `index` 排序, `index` 相等时, 下边在前***
5. ***求出每个区间内的所有小矩形(被覆盖的区域)的面积***   
   1. *对每一个区间, 初始化 `cnt = 0`, 遍历所有上下边, 同时记录当前是不是在覆盖的面积内*
   2. *如果线段区间不在该边的左右端点内, 不进行任何操作, 否则*
      1. *`last` 为上一个遍历的边的高度, 初始化为 `0`*
      2. *如果`cnt > 0` 表示在覆盖的面积内, 所以 `area += (interval.end - interval.start) * (line.index - last)`, 即区间宽度乘高度差*
      3. *另外如果是下边 `cnt + 1`, 是上边 `cnt - 1`, 此处直接加上 `flag` 的值即可*
6. ***如果同时记录 `cnt` 的最大值就得到了去年网易的题目答案***


### 解法2

1. ***构造纵坐标区间段存储 `Interval`, 包含起点和终点***
2. ***构造横坐标存储 `Node`, 包含对应矩形的纵坐标区间段 `interval`, 是否是矩形的右边界 `isEnd`, 横坐标位置***
3. ***对所有的横坐标排序 `nodes`***
4. ***对每一个横坐标作为右边界, 前一个横坐标作为左边界, 计算其中所有小矩形(被覆盖的区域)的面积***   
   1. *如果 `now.index = preIndex` *
      1. *计算当前所有纵坐标区间段 `intervals` 覆盖的总长度 `len`*
      2. *`area += (now.index - preIndex) * len`, 即区间宽度乘总高度*
   2. 如果该横坐标是矩形的右边界, 从当前纵坐标区间段 `intervals` 中移除 `now.interval`, 否则添加
